\chapter{Getting to know R}\label{rintro}
\chapterartfile{images/static/Rlogo.png}
\hypertarget{Rintro}{%
Just like a chef needs a set of tools, a kitchen with a convenient surface to work on, and a detailed cookbook with different recipes, a data scientist needs a powerful programming language, a convenient development environment, and good documentation.
In this chapter we provide a brief introduction to the \R language and the RStudio integrated development environment (IDE). Here, and in the remainder of the book we provide some essential `recipes' for data scientists.}

% for this book, and we hope that this book will be your basic guide into data science. In order to get started, you must first get the necessary software and get acquainted with it, and this is what this chapter is about.
 
\hypertarget{installing-r-and-rstudio}{%
\section{Installing \R and Rstudio}\label{installing-r-and-rstudio}}
To install \R go to the website of the Comprehensive R Archive Network (\url{https://cran.r-project.org/}) and download the latest version of \R for your operating system (Windows, MacOS, or Linux). %As of \today, the latest version is 4.0.4. 
Follow the installation instructions.

Next, go the Rstudio download website
(\url{https://rstudio.com/products/rstudio/download/}) and get the Desktop version
(open source license). %As of \today, the version is 1.4.1106. 
Follow the installation instruction.  An icon that looks like this
\includegraphics[height=0.02\textheight]{images/static/RstudioLogo.png}
will be on your computer's desktop. Double-click on this icon to start the \R session. The Rstudio IDE will open, and will look like this:

\begin{center}
  \includegraphics[width=0.8\linewidth]{images/static/RstudioMain}
\end{center}

The left-hand side of the screen contains the Console tab. Notice the \(>\) sign (called the `prompt'). When you see this character, it means that \R is ready for the next command. Put the cursor there, and then type

\begin{minted}{R}
2 + 2
\end{minted}
and hit Enter on the keyboard. You should get the following on the Console:

\begin{tcolorbox}[colframe=blue!25,colback=blue!10]
\begin{minted}{text}
[1] 4
\end{minted}
\end{tcolorbox}

Notice the top-right part of the Rstudio window. You should see an `Environment' and a `History' tab. Click on History. All your previous input appears there. Try entering another calculation or command in the console and see that they appear in the session's history. For example, try entering the following

\begin{verbatim}
date()
\end{verbatim}


Click on the Environment tab. It should be empty when you start \R for the first time. In the Console, type

\begin{verbatim}
myFirstVariable <- factorial(5)
\end{verbatim}

Notice that nothing was printed in the Console, but the Environment tab now contains a table with one row, with `myFirstVariable' appearing in the cell on the left, and its value (120) on the right. Any object appearing in the Environment tab is available to you throughout your \R session, and you don't have to redefine or recalculate it. For example, type the following in the console:

\begin{verbatim}
myFirstVariable/6
\end{verbatim}
The Console should now display 20.

The lower-right side of the IDE has a few tabs: Files provides a file browser, Packages provides information about installed packages (more about it later), Plots will contain any plot generated during the \R session, and the Help tab is used to obtain information about built-in functions.

Finally, before we move on to the next section, in the Rstudio top menu, click on File, then on New File, and then on \R Script. Alternatively, you can click on little green `+' icon in the top-left part of the IDE. This will split the left side of the Rstudio IDE into two parts -- the lower part will contain the Console, and the top part will contain a tab labeled `Untitled1'. This is where you can enter \R code which you will save to a permanent file, and re-use later.
For example, enter the following in the blank space in the Untitled1 tab:

\begin{verbatim}
# This is my first R program
cat("Hello, World!\n")
\end{verbatim}


Then, from the main menu in Rstudio, click on File, then on Save, and in the `Save As' box enter FirstProgram.R and click the Save button. Notice that the tab name is now FirstProgram.R.

In that part of the window, there should now be a small button called Source. Click on it. The program will be executed and the output will be shown in the Console. You can also execute individual lines in the source code. Just put the cursor anywhere in that line, and click on the Run button (which is near the Source button) or click Ctrl+Enter (or Command+Enter on a Mac). 

When you want to finish your \R session, just type \code{quit()}.

That's it. You are now ready to start learning programming in R.


\section{Basic Operations in R}
\subsection{Some Useful Functions}
\runR{Code/ch1sec1.R}{ch1init}%[cache]
\runR{Code/ch1sec2.R}{ch1init2}%[cache]
\runR{Code/ch1sec3.R}{ch1init3}%[cache]
\runR{Code/ch1sec3b.R}{ch1init3b}%[cache]
\R has many built-in functions, and many more in external packages. We will introduce them as we go, but let's get started with some basic ones.
The documentation on each function can be obtained by using \code{?func} or \code{help(func)} where \texttt{func} is some function. For example, to get the documentation about using the \code{date()} function, try the following:
\showCode{R}{Code/ch1sec1.R}[1][2]

When we start an \R session, it is important to determine the `working directory'. This is the folder on our computer which \R will use to search for data or code files and where it will save results (unless we explicitly specify another directory). To find out which folder is currently used, we use the following:
\showCode{R}{Code/ch1sec1.R}[5][5]
Try it! We sometimes refer to the complete directory information as `path',
since it tells us how to get to a specific file, starting from the root
directory (which is denoted by `\slash' on Mac and Linux, or  `Drive:\textbackslash' on Windows). The path corresponds to the hierarchical organization of folders (directories) on your computer.

If we want (and we often will), we may change the working directory by using
\code{setwd()}.  For example, we may create a folder `work' in our home
directory and then use the following line to set the working directory to it:
\begin{minted}{R}
setwd("~/work")
\end{minted}
% \showCode{R}{Code/ch1sec1.R}[6][6]
The \verb|~/| notation is a shortcut to your home directory. Using this shortcut is convenient because if you are using different computers or you share code with others, the home directory may be different on each computer.

\bigskip

Data are stored in `\textit{variables}'. We can get the data from a local file (Excel, comma-separated values, etc.), the Internet, or we can generate them ourselves. Let's start by generating some data.
The simplest function to create data is called \code{c()}, which stands for `combine'.
\showCode{R}{Code/ch1sec1.R}[9][9]
We created a variable called \code{courseNames}, and it contains three values. We assigned the values into the variable by using the \verb|<-| operator. 
We can now do things with this variable. For example, we check the variable type, using the \code{class()} function:
\showCode{R}{Code/ch1sec1.R}[10][10]
\noindent In this case we see that this variable is used to store text (`character' class):
\inlnR{```print(class(courseNames))```}[vbox]
%\includeOutput{ch1ex1class}

We can also get a bit more detailed information by checking its structure, using the \code{str()} function:
\showCode{R}{Code/ch1sec1.R}[11][11]
\noindent which shows that the variable is of class `character', and it is a vector with three values:
\inlnR{```str(courseNames)```}[vbox]
We can also get the number of elements in a vector by using the \code{length()} function, 
\showCode{R}{Code/ch1sec1.R}[12][12]


Pick good variable names. They should describe the meaning of the value, yet be
short enough to type. Variable names can only contain letters, numbers, the dot
character, and the underline character. Variable names can only begin with
either a letter, or a dot as long as it is not followed by a number. They should
be different from an existing function name or other reserved words in the language (like `while', `if', `quit'.)

We often have to generate variables which contain sequences of numbers. To do that, we use the \code{seq()} function. For example, we can create a variable which contains all the odd numbers between 1 and 20:
\showCode{R}{Code/ch1sec1.R}[14][14]
The variable \code{oddLT20} contains the following values: \inlnR{```cat(paste(oddLT20))```}.
%\runR{Code/ch1ex2.R}{ch1ex2}[cache]
%\includeOutput{ch1ex2}
To generate consecutive values, we can also use the colon operator. For example, try:
\showCode{R}{Code/ch1sec1.R}[18][18]
Note that the parentheses surrounding the whole line cause \R to print the content of the variable \code{firstThirteen} in the console.

Another useful function to generate data is \code{rep()}, which replicates values. We often have to generate a vector consisting of a single value (e.g., a vector of ones or zeros), and we can do it like in the following example. We use this opportunity to also introduce the sum and cumulative sum functions, \code{sum()} and \code{cumsum()}.
\showCode{R}{Code/ch1sec1.R}[20][22]
The variable \code{ones} contains the values: \inlnR{```cat(paste(ones))```}, and the sum is  \inlnR{```cat(sum(ones))```}. Their cumulative sum of \code{ones} is  a vector of length 10, such that the first value is just the first element of \code{ones}, the second value is the sum of the first two elements in \code{ones}, and so forth: \inlnR{```cat(paste(cumsum(ones)))```}.
%\inlnR{```ones <- rep(1, 10); cat(ones)```}[vbox]
Try the following: \code{cumsum(cumsum(ones))} (but first try to think what the result will be).

There are also many functions to handle text. The \code{paste()} function attaches two strings of characters together. The default is to concatenate strings with a space as a separator, but we can use the collapse option (also called an `argument' of the function) to use a different separator. For example,
\showCode{R}{Code/ch1sec1.R}[24][25]
%\inlnR{```cat(paste(courseNames))```}
\noindent The second line generates the following: \inlnR{```cat(concatvar)```}.
%%\replace{cat(paste(courseNames, collapse=", "))}{"}{x22}
%%\inlnR{```cat(paste(courseNames, collapse=x22, x22))```}
%%\inlnR{\replace{```cat(paste(courseNames, collapse=", "))```}{"}{x22}}
%%\inlnR{```\replace{cat(paste(courseNames, collapse=", "))}{"}{x22}```}

Let's combine what we've learned so far to create the 52 cards  in a standard deck, which includes four suits: Club, Diamond, Heart, and Spade:
\showCode{R}{Code/ch1sec1.R}[28][29]
Run each line separately, and check the content of `suits' and what
\code{rep(1:13, 4)} generates. Note that the function \code{paste0()} is the same as \code{paste(..., collapse="")}. The content of the cards variable is:
\inlnR{```cat(paste(cards))```}[vbox]


Let's `deal' five cards to each player in a game of poker. We will use the \code{sample()} function.
\showCode{R}{Code/ch1sec1.R}[32][33]
The \code{sample()} function in this example is used to draw 20 cards at random from the deck, without replacement. Then, to divide it into four hands, we use the \code{matrix()} function, and specify the number of rows and the number of columns.
The \code{sample()} function draws a different random sample each time unless we set the random `seed' to a fixed value. The \code{set.seed()} function is used to ensure the reproducibility of the results.  Try running the code without the \code{set.seed()} line, and see that you get different results each time.
\inlnR{```print(pokerHand)```}[vbox]

Check the class and the structure of the variable pokerHand, using the functions we've mentioned earlier.

We can save variables to a file in order to use them in a later session. For example, create a folder called `tmp' in your working directory, and type:
\showCode{R}{Code/ch1sec1.R}[35][35]
If we don't specify the path, the file will be stored in the current working directory. Recall that you can find out which directory is used with the \code{getwd()} function, and set it to another directory with \code{setwd()}.
Then, we may get the saved variables by using the following:
\showCode{R}{Code/ch1sec1.R}[36][36]
Variables which we do not save will not be available once we terminate the current \R session. When we quit an \R session we have an option to save the entire session's information. However, if there are variables, datasets, or functions which we have created and want to save, it's better to save them explicitly. After you use the \code{load()} function in the example above, the variable pokerHand will be available to use, even if you quit the \R session in which the variable was created.

We can also save and/or load data using other file formats that are easier to edit without \R. For
example, the following code save \code{plkerHand} in a comma-separated value (CSV) file and read it as
another variable called \code{pH}: 
\showCode{R}{Code/ch1sec1-rwdata.R}
\runR{Code/ch1sec1-rwdata.R}{rwdata}
The output is:
\includeOutput{rwdata}

There are a few constants in \R, including the letters of the alphabet (upper- and lower-case), the month names, and the number $\pi$. Try running the following:
\showCode{R}{Code/ch1sec1.R}[38][42]
The output for the third line is:
\inlnR{```cat(month.abb)```}[vbox]


The base distribution of \R is very comprehensive, but there are thousands of contributed packages which are written by \R users. We will use several such packages in the book, so let us demonstrate the basic usage.
The package \pkg{lattice} provides `elegant high-level data visualization system with an emphasis on multivariate data'. To install the package, we use the \code{install.packages()} function. In order to use the package, you have to load it using the \code{library()} function:
\showCode{R}{Code/ch1sec1.R}[45][46]

Installing the package has to be done just once. Occasionally, you may be prompted to install updates, which can also be done by using the function \code{update.packages()}. Loading a package has to be done each time you begin a new \R session.

In the following example we use a built-in dataset of opera singers, and we plot their heights by their vocal parts (Figure~\ref{fig:ch1:operaheight}).

\showCode{R}{Code/ch1sec1.R}[48][49]
\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{images/chapter_1/operaheight.pdf}
\caption{Using the lattice package to create boxplots.}\label{fig:ch1:operaheight}
\end{figure}
\noindent We will learn a lot more about data visualization in subsequent chapters.


\subsection{Writing your own functions}
One of the greatest things about computers is that they can do the same thing many times and not get tired. When we have to compute something many times, it is useful to create a sequence of commands (which we call a function) and give it a name. Then, we don't have to type the whole sequence of commands each time we want to run them -- we can simply run the function. For example, we can define a function for calculating the sum of numbers. Of course, such a function exists in \R, but we just use it to show how you can define your own function, and we will check that it produce the same result as the base \code{sum} function. 
\showCode{R}{Code/ch1sec1-defFunc.R}
\runR{Code/ch1sec1-defFunc.R}{defFunc}
\includeOutput{defFunc}

The function \code{mysum} that we defined, takes one argument from the user, called \code{x}. This is useful because you can use the same function to perform a similar operations on different objects. For example, you can try
\showCode{R}{Code/ch1sec1-defFuncUsage.R}

Functions can take more than one argument, or no arguments at all. The arguments can also be given a default value, so that if the user does not specify them it will not cause an error. For example, we can create a function to deal poker hands to varying number of players, and we can also choose the number of cards each player gets:
\showCode{R}{Code/ch1sec1-PokerHand.R}
Note that we also introduced some error-checking: the function checks if the input is valid, since it's not possible to deal more cards than we have in one deck. If an error is detected, the function uses the built-in \code{stop()} function to abort, and show an error message to the user.  Checking the validity of the input is very important and helpful to the user.


\subsection{Generating random numbers}
In this book much of the learning will be done by using simulated data, so let's start by learning how to generate data. The basic function to generate random data is \code{runif()} which is used to draw random numbers uniformly between 0 and 1. In the following example we create 10,000 random draws from a uniform distribution, we keep these numbers in a variable called simData, and then plot a histogram to show the distribution of the data we have generated. The \code{set.seed()} function is used to ensure that every time we run this code, we will get the same set of random numbers. This is called \textit{reproducible code}. 
\showCode{R}{Code/ch1sec2.R}[2][6]
\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{images/chapter_1/simunif1.pdf}
\caption{A histogram of a random sample from a standard uniform distribution.}\label{fig:ch1:simunif1}
\end{figure}



From the range and the flatness of the histogram in Figure~\ref{fig:ch1:simunif1} we can see that the generated data is indeed uniform on [0,1]. The \code{runif()} function can be used to draw random numbers uniformly on any finite interval. For example, if we want our random numbers to be in the interval [1,5] we will run the following code:
\showCode{R}{Code/ch1sec2.R}[9][10]
\noindent Try it, and draw the histogram as in the previous example. Try it with
a fixed seed and verify that you get the same output each time. Then, run the
code without a fixed seed and observe that you get different data each time. Since the number of random draws is fairly large, the shape of the histogram will not change much.

From a random draw of a uniform distribution we can generate random numbers from
other distributions. For example, we want to simulate (fair) coin flips, and
count the number of Heads that we get. Let's say we want to simulate 200 coin
tosses. We will draw 200 random numbers from a uniform distribution, and decide
that we got a Head in the $i$-th toss if the $i$-the random number is less than
0.5, and a Tail otherwise.
Try the following code multiple times (do not use \code{set.seed()}). What do you observe? We will discuss it further in a different chapter.
\showCode{R}{Code/ch1sec2.R}[13][15]
A few comments:
\begin{itemize}
\item A comment in \R starts with \#. Any text following the \# sign is considered user-documentation and is not executed by \R.
\item We have used the \code{cat()} function to print (concatenate) text to the console. Fixed text appears in double (or single) quotes, but the content of variables or output from \R functions should not be quoted. The \verb|\n| symbol tells \R to print a newline character. Try to see what happens if you remove it.
\item The expression within the \code{sum()} function produces TRUE/FALSE (Boolean) values. First, we draw n.trials random numbers from a uniform distribution. Then, each one is compared with 0.5. If the value is less than 0.5, the returned value is TRUE. Otherwise, it's FALSE. This demonstrates one of \R's greatest features - allowing to run `vectorized' code. In one line, we generated 200 random numbers and for each one we checked if it is less than 0.5, and as a result, we got 200 Boolean values which we have added together (TRUE counts as 1, and FALSE counts as 0.) Thus, the result in the sum is the number of Heads in 200 tosses.
\end{itemize}

The number of Heads we get (with this seed) is \inlnR{```cat(sum(runif(n.trials) < 0.5))```}. Statistical inference is based on a mental exercise in which we ask, if we could repeat the same experiment infinitely many times, what would we see? With simulations, we can get a good approximation. For example, the 200 coin-tosses experiment can be repeated, say, 100 times. One way is to use loops, like in the following example:
\showCode{R}{Code/ch1sec2.R}[18][25]
We've used a \code{for()} loop, with an index variable called \texttt{i} which runs from 1 to 100. In each iteration we simulated n.trials=200 coin tosses, as before. The result from each iteration is stored in the $i$-th position in the vector we called Heads. Figure~\ref{fig:ch1:simunif2} shows the distribution of 100 simulations, each of which consists of 200 coin tosses and from each of the 100 simulations we obtain the proportion of times we got Heads.

\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{images/chapter_1/simunif2.pdf}
\caption{A histogram of 100 experiments in which we flip a coin 200 time and calculate the proportion of times we get Heads out of 200.}\label{fig:ch1:simunif2}
\end{figure}

Using the uniform distribution, we have created a random draw from a different distribution, called the `binomial'. The mathematical notation is $Bin(N, p)$ where $N$ is the number of trials such that in each trial there can be exactly two outcomes (e.g., Heads or Tails in coin tosses), and $p$ is the probability of the first possible outcome (e.g., Head), and $1-p$ is the probability of the second possible outcome (e.g., Tail).
\R has a built-in function to generate random numbers from many different distributions, including the binomial so the code above can be replaced by the following, which uses the \code{rbinom()} function:
\showCode{R}{Code/ch1sec2.R}[29][33]


\begin{exercise}\-
\begin{enumerate}
\item Change the number of simulated coin-toss simulations (\texttt{reps}) to 1,000 and rerun the code. Then change it to 10,000 and run it again. What do you notice?
\item Change the probability of Heads to 0.2 and run the code again. Then, change it to 0.8. What do you observe?
\item Try other values of the number of trials and the probability of Heads.
\end{enumerate}
\end{exercise}

\subsection{Summary statistics}

We will introduce some statistical functions to summarize data. To demonstrate some of these functions, let's first generate some data:

\showCode{R}{Code/ch1sec3.R}[1][4]
Note that in \R the \code{log} function uses the natural logarithm by default. To use base 10 or base 2, use \code{log10} and \code{log2}, respectively. To specify another base, use the \code{base} argument. For example, try  \code{log(16, base=4)}.

The most commonly used statistical summary is the mean (a.k.a. the average), $\overline{x}$:\\
$$\overline{x}=\frac{x_1+\ldots+x_n}{n}\,.$$
Other ways to estimate some sort of `central tendency' of a distribution are:
 \begin{itemize}
 \item The trimmed mean, which is similar to the mean, except that the smallest and largest $p\cdot 100\%$  of the values are excluded from the computation. In our example, if we take $p=0.1$ with the simulated data, only 8,000 data points will be used in the calculation of the trimmed mean; 
 \item The median, which is a number (denoted here by $x_{0.5}$) such that half the data points are greater than $x_{0.5}$ and half are less than or equal to $x_{0.5}$. 
 \end{itemize}
Let's compute the sample's mean, trimmed mean, and median. Notice that  in this example the mean is greater than trimmed mean, which is greater than the median. In general, the mean is not a great estimate of the `center' of a non-symmetric distribution. We say that the mean is more `sensitive to extreme values' than the median.
\showCode{R}{Code/ch1sec3.R}[7][9]
In this example with n=\inlnR{```cat(n)```} random numbers we get that the mean
is \inlnR{```cat(mean(x))```}, the trimmed mean is  \inlnR{```cat(mean(x, trim=0.1))```}, and the median is \inlnR{```cat(median(x))```}.

The formula we used, \code{x <- -log(runif(n))/lambda}, generates random number from the so-called exponential distribution with rate parameter $\lambda=10$. We denote it by $X\sim \exp(\lambda)$. The exponential distribution is often used to model random waiting times, like the time between incoming text messages. We would usually generate it by using the \code{rexp()} function in \R, like this: \code{x <- rexp(n, lambda)} .
Mathematical analysis of the distribution leads to the fact that the expected value of an exponential random variable with rate $\lambda$, is $1/\lambda$. We see that the theoretical expected value of our example is 0.1, and the sample mean is very close to 0.1. This is no coincidence - we will discuss it in  later chapter.


The distribution of \texttt{x} is shown in Figure~\ref{fig:ch1:simexp} as a \textit{box-and-whisker plot} (or simply, boxplot). This is a very simple representation of numeric data, which is constructed by summarizing the data using a few numeric characteristics. In Figure~\ref{fig:ch1:simexp} the boxplot  is drawn horizontally, and the vertical grey line inside the box is the median. Similar to the median, we find the first quartile -- a point, $x_{0.25}$, such that 25\% of the values are less than $x_{0.25}$ and 75\% are greater than $x_{25}$; and the third quartile -- a point, $x_{0.75}$, such that 75\% of the values are less than $x_{0.75}$ and 25\% are greater than $x_{0.75}$. The first and third quartiles are the vertical edges of the box, also called the lower and upper hinges. So, the box represents the middle 50\% of the data. The range between the first and third quartiles is called the \textit{Inter-Quartile Range}, or IQR, which is sometimes used to estimate the dispersion or spread of the data.
The `whiskers', which are the dashed grey lines, are {\color{blue} the minimum
  and maximum observations within 1.5$\cdot$IQR to each side of the box}. If the result is smaller than the minimum value (or greater than the maximum), then the whisker only extends to the minimum (maximum). Points within the range between the two whiskers are not plotted individually, since their distribution is summarized succinctly by the box-and-whiskers plot. Points outside the range between the two whiskers are considered `outliers', or extreme values, and are shown explicitly. 

The plot was generated with the following code. Try it, and try changing some of the parameters to understand their role. We will cover the topic of visualization in chapter \ref{EDA}.

\showCode{R}{Code/ch1sec3.R}[12][16]

\begin{figure}
\centering
\includegraphics[width=0.95\textwidth]{images/chapter_1/expdistbp.pdf}
\caption{A boxplot of data generated from an exponential distribution with $\lambda=10$.}\label{fig:ch1:simexp}
\end{figure}


A boxplot does not include the mean, or the trimmed mean, but we have added them
here as a red circle and brown diamond, respectively, in order to show that they
are different than the median. The mean is larger than the median in this case,
so we say that the distribution is skewed to the right. 
   The median does not depend on observations in the tails
  of the data (small and large observations in the data). It simply represents
  where the data can be split in half. Thus the median is a more robust measure of
  the central tendency of the data than the mean, and it is more appropriate for
skewed data such as income.

A more detailed summary of a sample can be obtained by calculating its
quantiles. In the boxplot, only three quantiles (also called percentiles) are
shown. We can show the quantiles (20, 40, 60, 80 percentiles), or deciles (10,
20,\ldots, 90 percentiles) by using the \code{quantile()}
function. Figure~\ref{fig:ch1:simexp2} shows these quantiles as dashed vertical
lines in a histogram.

\showCode{R}{Code/ch1sec3.R}[20][25]

\begin{figure}
\centering
\includegraphics[width=0.7\textwidth]{images/chapter_1/expdisthist.pdf}
\caption{A histogram of a sample from an exponential distribution, with the 10, 20, 30,... percentiles.}\label{fig:ch1:simexp2}
\end{figure}



In addition to sample statistics which summarize some notion of the center of
the distribution, we are often interested in estimating the dispersion of the
data. The most commonly used measures of dispersion are the variance, and its
square root - the standard deviation. The sample variance is defined as follows

$$Var(x)=\frac{(x_1-\overline{x})^2+\ldots+(x_n-\overline{x})^2}{n-1}$$
where $\overline{x}$ is the sample mean $\mu$.
% is the mean of the distribution of $X$.
In words, the variance is the average of the squared deviations from the mean.
Notice that the sample variance is computed with $n-1$ in the denominator
because with $n-1$ we get an `unbiased estimator' for the true variance.

The corresponding functions in \R are \code{var()} and \code{sd()} for sample
variance and standard deviation, respectively. In the following code we also demonstrate the \code{IQR()} function.

\showCode{R}{Code/ch1sec3.R}[28][30]

We will see in subsequent chapters that the normal distribution plays a major role in statistics. It is defined by a probability density function, with two parameters -- $\mu$ and $\sigma^2$:
$$\phi(x; \mu,\sigma^2)=\frac{1}{\sqrt{2\pi\sigma^2}}\exp\left[-\frac{(x-\mu)^2}{2\sigma^2}\right]\,.$$
It is symmetric, `bell-shaped', and centered around the mean, $\mu$, as shown in
Figure~\ref{fig:ch1:simnorm}. The blue histogram is generated by drawing random
numbers from a normal distribution, using the \code{rnorm()} function. Here, we
use $\mu=2.5$ and $\sigma^2=0.25$. The orange curve shows the function $\phi$, by using the \code{dnorm()} function (to obtain the density function of $x$).
\showCode{R}{Code/ch1sec3.R}[33][36]
\begin{figure}
\centering
\includegraphics[width=0.7\textwidth]{images/chapter_1/normdisthist.pdf}
\caption{A histogram of a sample from a normal distribution, with mean=2.5 and variance=0.25.}\label{fig:ch1:simnorm}
\end{figure}

We can obtained more detailed summaries about the sample, by using the  \code{summary()} function. It gives the minimum, maximum, the 25th, 50th, and 75th percentiles, as well as the mean of the sample. Using the random numbers from the normal distribution in the previous code:
\showCode{R}{Code/ch1sec3.R}[39][39]
\inlnR{```print(summary(x))```}[vbox]
Another possibility (among many) to summarize data in \R is the \code{describe()} function from the psych package, 
\showCode{R}{Code/ch1sec3.R}[40][40]
It gives the sample size, the standard deviation, the trimmed mean, the mean
absolute deviation (mad), the range (maximum minus minimum), the skewness, and
the kurtosis \textcolor{red}{will we use the kurtosis later? If so, we should
  add a ref.} \why{It doesn't seem that we will for this book, so maybe we do
  not show the describe function.}.
\inlnR{```print(psych::describe(x))```}[vbox]

We conclude this chapter with some functions which can be used to summarize discrete (categorical) data, where the mean, variance, quantiles, etc. are not applicable. We will revisit the topic of summarizing data in chapter \ref{EDA}.

To simulate categorical data we can use the \code{rmultinom()} function, which simulates putting $N$ objects in $K$ bins with given probabilities for each bin. Another possibility is to use \code{cut()} function which divides a range of numbers into discrete ranges and creates discrete categories in a factor variable.
For example, suppose there is a town with three hotels (Motel 6, Best Western,  and Hilton) with 400, 300, and 300 rooms, and one auto rental company with only two makes of cars (700 Honda, and 300 Teslas). In the following code we simulate the allocation of 100 visitors to hotels and cars. We use the \code{table()} function to show the counts by hotel, by car, and by both. 
\showCode{R}{Code/ch1sec3.R}[42][48]
\inlnR{```print(table(hotelrooms))```}[vbox]
\inlnR{```print(autotbl <- table(autorental))```}[vbox]
\inlnR{```print(table(hotelrooms, autorental))```}[vbox]


We can use the \code{max()} and \code{which.max()} functions to find the mode of the data (the most frequent value).
\showCode{R}{Code/ch1sec3b.R}[1][2]
The hotel with the largest number of guests is \inlnR{```cat(levels(hotelrooms)[which.max(hoteltbl)])```} with \inlnR{```cat(max(hoteltbl))```} guests, and \inlnR{```cat(levels(autorental)[which.max(autotbl)])```} is rented to \inlnR{```cat(max(autotbl))```} people.

%%% Local Variables:
%%% mode: latex
%%% TeX-command-extra-options: "-shell-escape"
%%% TeX-engine: xetex
%%% TeX-master: "../sidsmain.tex"
%%% End: