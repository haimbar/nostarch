\chapter{Introduction to R}\label{rintro}
Just as a chef needs a set of tools, a kitchen surface, and a detailed cookbook,
a data scientist needs a powerful programming language, a convenient 
development environment, and good documentation.
In this chapter we'll provide a brief introduction to the \R language and the 
RStudio integrated development environment (IDE). Here, and in the remainder 
of the book we'll provide some essential ``recipes'' for data scientists.


% for this book, and we hope that this book will be your basic guide into data science. In order to get started, you must first get the necessary software and get acquainted with it, and this is what this chapter is about.
 
\hypertarget{installing-r-and-RStudio}{%
We'll begin with instructions for how to install the necessary software, and
then demonstrate some basic usage. We'll then introduce some fundamental 
concepts such as working directories, variables, and functions, and we'll show 
how to generate random data. You will also learn how to write your own
functions.  We'll conclude with a brief hands-on introduction to summary
statistics. % no blank line here because of the hyptertarget defn
\section{Installing \R and RStudio}\label{installing-r-and-RStudio}}
To install \R go to the Comprehensive R Archive Network \index{CRAN, the 
Comprehensive R Archive Network} website: 
\url{https://cran.r-project.org/}.  Download the latest version of \R for
 your operating system (Windows, macOS, or Linux), and then   
follow the installation instructions.


Next, we will install RStudio, which is an integrated development environment (IDE).
\index{Integrated development environment (IDE)}
An IDE is a software tool which allows users to conveniently view and edit code and text,
and to generate plots and reports. There are many IDEs, and we chose RStudio
which is especially popular among R users.
Go the Posit website for RStudio:\index{RStudio}
\url{https://posit.co/download/rstudio-desktop/}. Download the Desktop version
(open source license), and %As of \today, the version is 1.4.1106. 
follow the installation instructions.  An icon that looks like an R in a
blue circle will appear on your computer's desktop. Double-click this icon to
start the \R session. The RStudio IDE should open, and it should look like
Figure~\ref{fig:r_studio}.

%\jy{Why not the whole linewidth for figures? Is this their style?}
% Yes - they want figures aligned to the left. We can make them bigger,
% but when the aspect ratio should be 1, it may be harder to do -- the figures
% should not take too much of a page (they use book page size, so the
% area is smaller than in papers.)
% For example, with Fig. 2.1 it will not look to spread it across the page

\begin{figure}[H]
  \includegraphics[width=0.8\linewidth]{images/static/RStudioMain}
  \caption{The RStudio window}
  \label{fig:r_studio}
\end{figure}


The left-hand side of the screen contains the Console tab. Notice the
 \lstinline{>} sign; this is called the \emph{prompt}. When you see this
character, it means that \R is ready for the next command. Put the cursor there,
and then enter
% \jy{I didn't realize that the input and output are hard-coded.}
% Only here. Later they are not. 

\begin{lstlisting}
> ***2 + 2***
\end{lstlisting}

You should get the following output:

\begin{lstlisting}
[1] 4
\end{lstlisting}


Notice the top right part of the RStudio window. You should see both an
Environment and a History tab. Click on \textbf{History}. 
\index{RStudio!Environment and History}
All your previous input appears there. Try entering another calculation or command in the console.
For example, try entering the following:  

\begin{lstlisting}
> ***date()***
\end{lstlisting}

You should see that this command appears in the session's history.


Now click on the \textbf{Environment} tab. It should be empty when you start \R
for the first time. In the console, enter

\begin{lstlisting}
> ***myFirstVariable <- factorial(5)***
\end{lstlisting}

Notice that nothing was printed in the Console, but the Environment tab
now contains a table with one row, with \lstinline{myFirstVariable} appearing
in the cell on the left and its value, \lstinline{120}, on the right. Any object
appearing in the Environment tab is available to you throughout your 
\R session, and you don't have to redefine or recalculate it. For example,
enter the following in the console:

\begin{lstlisting}
> ***myFirstVariable / 6***
\end{lstlisting}

The console should now display \lstinline{20}.

\index{RStudio!File browser}
The lower-right side of the IDE has a few tabs: Files provides a file browser,
Packages provides information about installed packages (we'll discuss these
more later), Plots will contain any plot generated during the \R session, and
the Help tab is used to obtain information about built-in functions.

Finally, before we move on to the next section, in the RStudio top menu, click
on \textbf{File}, then on \textbf{New File}, and then on \textbf{R Script}. 
Alternatively, you can click on the little green plus icon in the top-left part of the IDE.
This will split the left side of the RStudio IDE into two parts: the lower part will
contain the Console, and the top part will contain a tab labeled Untitled1.
This is where you can enter \R code that you will save to a permanent file
and can re-use later.

For example, enter the following in the blank space in the Untitled1 tab:

\begin{lstlisting}
# This is my first R program
cat("Hello, World!\n")
\end{lstlisting}

Don't worry about what this code does for now. From the main menu in RStudio,
click on \textbf{File}, then on \textbf{Save}, and in the Save As box enter 
\textbf{FirstProgram.R}; click the \textbf{Save} button. You should now have a file
named \emph{FirstProgram.R}; notice that the tab name is now FirstProgram.R.


In that part of the window, there should now be a small button called Source.
Click on it. The program will execute and the output, \lstinline{Hello, World!},
should be shown in the console. If you want to execute individual lines in the
source code, put the cursor anywhere in that line, and click on the Run button
(which is near the Source button) or click Ctrl+Enter (or Command+Enter on a Mac). 


When you want to finish your \R session, just enter \lstinline{quit()}
into the console, and confirm with Yes when prompted to confirm.
Congratulations! You're now ready to start learning programming in R.


\section{Some Useful R Functions}
\runR{Code/bookinit.R}{bookinit}%[cache]
\runR{Code/ch1sec1.R}{ch1init}%[cache]
\runR{Code/ch1sec2.R}{ch1init2}%[cache]
\runR{Code/ch1sec3.R}{ch1init3}%[cache]
\runR{Code/ch1sec3b.R}{ch1init3b}%[cache]

\R has many built-in functions, and many more found in external 
\emph{packages}  that have been written by \R users in order to extend
the language. We will introduce functions and packages as we go, but
let's get started with some basic ones.
The documentation for each function can be obtained by using 
\lstinline{?___<function>___} or \lstinline{help(___<function>___)} where 
\lstinline{___<function>___} is the function you're interested in. For example,
to get the documentation for \lstinline{date()}, try either line of the following:
\index{R command!\code{help}}

\showCode{R}{Code/ch1sec1.R}[1][2]
% \showChunk{R}{Code/ch1sec1.R}{ch1sec1-1}

\subsection{Changing Your Working Directory}
When we start an \R session, it's important to determine the \emph{working directory}.
\index{R command!\code{getwd}}
This is the folder on our computer that \R will use to search for data or code files, 
and it's where \R will save results (unless we explicitly specify another directory).
To find out what our working directory is, we can use the following:
% \showChunk{R}{Code/ch1sec1.R}{ch1sec1-1}
\showCode{R}{Code/ch1sec1.R}[5][5]
We sometimes refer to the complete directory information as the \emph{path},
since it tells us how to get to a specific file, starting from the root
directory (which is denoted by a ~\emph{\slash} on Mac and Linux, or  
\emph{Drive:\textbackslash} on Windows). The path corresponds to the hierarchical
organization of folders (or directories) on your computer.


We can change the working directory by using \index{R command!\code{setwd}}
\lstinline{setwd()}.  For example, we may create a folder \emph{work} in our home
directory and then use the following line to set the working directory to it:
\begin{lstlisting}
> ***setwd("~/work")***
\end{lstlisting}
The \lstinline{~/} notation is a shortcut to your home directory. Using this shortcut is
convenient because if you are using different computers or you share code with others,
the home directory may be different on each computer.


\subsection{Working with Variables}
Data is stored in \textit{variables}.
% AF: Don't think I'd specify the types of files yet. Only distracts.
%We can get the data from a local file, the Internet, or we can generate it ourselves.
% AF:  We do data as singular, per the style guide.
Let's start by generating some data.
The simplest function to create data is  \lstinline{c()}, which stands for ``combine.'' 
\index{R command!\code{c}, combine}
We can use it like so:
% \showChunk{R}{Code/ch1sec1.R}{ch1sec1-1}
\showCode{R}{Code/ch1sec1.R}[9][9]
Here we've created a variable called \lstinline{courseNames}, and it contains 
three values: \lstinline{Data Science}, \lstinline{Statistics}, and \lstinline{Probability}.
We assigned the values into the variable by using the \lstinline{<-} operator. 


We can now do things with this variable. For example, we check the variable type,
using the \lstinline{class()} function:
% \showChunk{R}{Code/ch1sec1.R}{ch1sec1-1}
\showCode{R}{Code/ch1sec1.R}[10][10]
\noindent In this case the output should be \index{R command!\code{class}} \index{R command!\code{cat}}
 \inlnR{```cat(class(courseNames))```}[introcoursenames], which means that this variable is
 used to store text. % (\lstinline{character} class):
%\inlnR{```print(class(courseNames))```}[vbox]
%\includeOutput{ch1ex1class}
We can also get a bit more detailed information about a variable by checking
its structure; to do this, we use the \lstinline{str()} function:\index{R command!\code{str}}
\showCode{R}{Code/ch1sec1.R}[11][11]
% \showChunk{R}{Code/ch1sec1.R}{ch1sec1-1}
\noindent As you should see in the output, this shows that the variable is of class 
\lstinline{chr} (which stands for character), and it has three values:
\inlnR{```str(courseNames)```}[introstrcoursenames][vbox]
% AF: Spacing here is off at the bottom. Too much space after the frame. Can we use \lstlisting instead?


Our \lstinline{courseNames} is what's called a \emph{vector}, a one-dimensional
array of objects of the same type (in this case, strings of characters).
We can also get the number of elements in a vector by using the \index{R command!\code{length}}
\lstinline{length()} function:
\showCode{R}{Code/ch1sec1.R}[12][12]
% \showChunk{R}{Code/ch1sec1.R}{ch1sec1-1}


Pick good variable names. They should describe the meaning of the value, yet be
short enough to type. Variable names can only contain letters, numbers, the dot
character (\lstinline{.}), and the underline character (\lstinline{_}). They can only
begin with a letter or a dot that is not followed by a number. They should
be different from an existing function name or other reserved words in the language
(like \lstinline{while}, \lstinline{if}, \lstinline{quit}).


\subsection{Generating Data}
We often have to generate variables that contain sequences of numbers. To do that,
we use the \lstinline{seq()} function. For example, we can create a variable that
\index{R command!\code{seq}}
contains all the odd numbers between 1 and 20:
\showCode{R}{Code/ch1sec1.R}[14][14]
% \showChunk{R}{Code/ch1sec1.R}{ch1sec1-1}
The variable \lstinline{oddLT20} should contain the following values: 
\inlnR{```cat(paste(oddLT20))```}[introoddlt20].
% AF: This command was changing the font size of the rest of the PDF. I've gone into your commands and updated it so it no longer does this.
%\runR{Code/ch1ex2.R}{ch1ex2}[cache]
%\includeOutput{ch1ex2}
To generate consecutive values, we can also use the colon operator (\lstinline{:}). 
For example, try:
\showCode{R}{Code/ch1sec1.R}[18][18]
% \showChunk{R}{Code/ch1sec1.R}{ch1sec1-1}
Note that the parentheses surrounding the whole line cause \R to print the content
of the variable \lstinline{firstThirteen} in the console.


Another useful function to generate data is \lstinline{rep()}, which replicates values.
We often have to generate a vector consisting of a single value (for example, 
a vector of ones or zeros). We can do it like so:
\showCode{R}{Code/ch1sec1.R}[20][22]
% \showChunk{R}{Code/ch1sec1.R}{ch1sec1-1}
Note we've introduced two new functions: the sum (\lstinline{sum()}) and cumulative
sum (\lstinline{cumsum()}) functions.
The variable \lstinline{ones} contains the values: \inlnR{```cat(paste(ones))```}[introones],
and the sum is  \inlnR{```cat(sum(ones))```}[introsumones]. Their cumulative sum of
 \lstinline{ones} is  a vector of length 10, where the first value is just the first 
 element of \lstinline{ones}, the second value is the sum of the first two elements 
 in \lstinline{ones}, and so forth: \inlnR{```cat(paste(cumsum(ones)))```}[introcumsumones].
%\inlnR{```ones <- rep(1, 10); cat(ones)```}[vbox]
Before moving on, think about what the result of \lstinline{cumsum(cumsum(ones))}
will be, and then give it a try.


\subsection{Working with Text}
There are many functions to handle text. The \lstinline{paste()} function attaches two 
\index{R command!\code{paste}}
\index{R command!\code{cat}}
\emph{strings} of characters together. The default is to combine, or \emph{concatenate},
 strings with a space as a separator, but we can use the \lstinline{collapse} option 
 (also called an \emph{argument} of the function) to use a different separator. For example,
\showCode{R}{Code/ch1sec1.R}[24][25]
% \showChunk{R}{Code/ch1sec1.R}{ch1sec1-1}
%\inlnR{```cat(paste(courseNames))```}
\noindent Here we've used \lstinline{collapse} to specify that the strings should be 
separated by a comma followed by a space.  The second line generates the 
following: \inlnR{```cat(concatvar)```}[introcatvar].
%%\replace{cat(paste(courseNames, collapse=", "))}{"}{x22}
%%\inlnR{```cat(paste(courseNames, collapse=x22, x22))```}
%%\inlnR{\replace{```cat(paste(courseNames, collapse=", "))```}{"}{x22}}
%%\inlnR{```\replace{cat(paste(courseNames, collapse=", "))}{"}{x22}```}


\subsection{Using Contributed Packages}
\index{R Packages}
The base distribution of \R is very comprehensive, but there are thousands of contributed
packages written by \R users. We will use several such packages in the book, so let us
demonstrate their basic usage.
% AF: Let's do packages as regular text, as I mentioned on the call.
The package lattice provides ``elegant high-level data visualization system with an
emphasis on multivariate data.'' To install the package, we use the
\lstinline{install.packages()} function. In order to use the package, you have to load
it using the \lstinline{library()} function:
\showCode{R}{Code/ch1sec1.R}[45][46]
% \showChunk{R}{Code/ch1sec1.R}{ch1sec1-1}
\index{R command!\code{install.packages}}


Installing the package has to be done just once. Occasionally, you may be prompted
to install updates, which can also be done by using the \lstinline{update.packages()}
function. You have to reload the package each time you begin a new \R session.


To see a package in action, let's use a built-in dataset of opera singers and plot their
heights by their vocal range:

\showCode{R}{Code/ch1sec1.R}[49][50]
% \showChunk{R}{Code/ch1sec1.R}{ch1sec1-1}

The results should look like Figure~\ref{fig:ch1:operaheight}.

% \jy{Is it No-Starrch style to use H for positioning floats?}
% Yes - all this formatting was done with Alex's help and guidance

\begin{figure}[H]
\includegraphics[width=0.9\textwidth]{images/chapter_1/operaheight.pdf}
\caption{Using the lattice package to create boxplots}\label{fig:ch1:operaheight}
\end{figure}
\noindent We will learn a lot more about data visualization in subsequent chapters.


\section{Creating a Deck of Cards}
Let's combine what we've learned so far to create the 52 cards in a standard deck,
including four suits: clubs, diamonds, hearts, and spades. Here's our initial code:
\showCode{R}{Code/ch1sec1.R}[28][29]
% \showChunk{R}{Code/ch1sec1.R}{ch1sec1-1}
Run each line separately and check the content of \lstinline{suits} and what
\lstinline{rep(1:13, 4)} generates. Note that the function \lstinline{paste0()} is the
same as \lstinline{paste(..., collapse="")}. The content of the cards variable should be:
\inlnR{```cat(paste(cards))```}[introcards][vbox]
Now that we have our cards, let's use them.

\subsection{Getting Samples}
Let's `deal' five cards to each player in a game of poker. We will use the
\lstinline{sample()} function to do this: \index{R command!\code{sample}}
\showCode{R}{Code/ch1sec1.R}[32][34]
% \showChunk{R}{Code/ch1sec1.R}{ch1sec1-1}
The \lstinline{sample()} function in this example is used to draw 20 cards at random
from the deck; we don't put the cards back in the deck, so we say they were drawn
\emph{without replacement}. Then, to divide it into four hands, we use the
\lstinline{matrix()} function and specify the number of rows and the number of columns.
The \lstinline{sample()} function draws a different random sample each time unless we
set the random \emph{seed} to a fixed value. The \lstinline{set.seed()} function is
\index{R command!\code{set.seed}}
used to ensure the reproducibility of the results.  Try running the code without the
\lstinline{set.seed()} line, and you should see that you get different results each time.
When we create a matrix, we may want to name the rows and columns. If we choose
to do so, we can do it by using the \lstinline{dimnames} options, which is a \emph{list}
consisting of two vectors -- the first one is used to create row names, and the second
in used to name the columns.


This is what the results look like with the seed:
\inlnR{```print(pokerHand)```}[intropokerhand][vbox]


Check the class and the structure of the variable \lstinline{pokerHand}, using the
functions we've mentioned earlier.

\subsection{Saving to a File}
We can save variables to a file in order to use them in a later session. Create a
folder called \emph{tmp} in your working directory, and enter:
\showCode{R}{Code/ch1sec1.R}[36][36]
% \showChunk{R}{Code/ch1sec1.R}{ch1sec1-1}


If we don't specify the path, the file will be stored in the current working directory.
Recall that you can find out the working directory with the \lstinline{getwd()} function;
you can set it to another directory with \lstinline{setwd()}.


We can get the saved variables using the following:
\showCode{R}{Code/ch1sec1.R}[37][37]
% \showChunk{R}{Code/ch1sec1.R}{ch1sec1-1}
\index{R command!\code{save}}
\index{R command!\code{load}}
Variables that we don't save will not be available once we terminate the current
\R session. When we quit an \R session, we have an option to save the entire session's
information. However, if there are variables, datasets, or functions that we have created
and want to save, it's better to save them explicitly. After you use the \lstinline{load()}
function in the example above, the variable \lstinline{pokerHand} will be available
to use, even if you quit the \R session in which the variable was created.


We can also save and load data using other file formats that are easier to edit
without \R. For
example, the following code saves \lstinline{pokerHand} in a
\emph{comma-separated value (CSV)} file; a CSV file is one where each line
represents one observation, and  each observation consists of one or more
fields (columns) that are separated by commas. In our example, the rows correspond
to the four players, and the columns to the five cards each player was dealt.
In the code below, we read it as another variable called \lstinline{pH}: 
\showCode{R}{Code/ch1sec1-rwdata.R}
\runR{Code/ch1sec1-rwdata.R}{rwdata}
The output is:
\includeOutput{rwdata}
% AF: same here, want to avoid stacking. Add some explanation of the
% output.
%\jy{What do X and the colnames come from? Need to control them.}
% The code now shows how the dimnames are created.
% The X is added by read.csv, because we used row.names=TRUE, so it
% shows the player numbers as the row names, but adds an X. It's silly, but that's 
% how read.csv behaves.

In this example, player 3 got two aces (clubs and spades), the queen of hearts,
4-diamond, and 7 of spades.
\index{Comma-separated values (CSV)}
Note that when we saved the file as CSV we chose the  \lstinline{row.names=TRUE}
option, in order to preserve the row names. Also, note that when a column name has a 
space, \R replaces it with a period, since spaces are not allowed in variable names.
\index{R command!\code{read.csv}}
\index{R command!\code{write.csv}}

%There are a few constants in \R, including the letters of the alphabet (upper- and lower-case), the month names, and the number $\pi$. Try running the following:
%\showCode{R}{Code/ch1sec1.R}[38][42]
%If you run the code above, you should see this output:
%\inlnR{```cat(month.abb)```}[vbox]

\section{Writing Your Own Functions}
A nice feature of computers is that they can do the same thing many times and
not get tired. When we have to compute something many times, it's useful to
create a sequence of commands and give it a name---we'll call that named
sequence of commands a \emph{function}. \index{Functions in \R}
Once we have a function, we don't
have to type the whole sequence of commands each time we want to run them;
we can simply run the function. For example, we can define a function for calculating
the sum of numbers. Of course, such a function already exists in \R, but we'll
recreate it to show how you can define your own, and we will check that it produces
the same result as R's \lstinline{sum()} function.  Here's our version:
\showChunk{R}{Code/ch1sec1-defFunc.R}{funcdef}
%\showCode{R}{Code/ch1sec1-defFunc.R}[1][7]
% AF: Wingdings aren't rendering correctly. Are they escaped using (@ and @)?
% AF: Also, wingdings should be in front of the object they describe (unless it's a codewide environment, in which case it goes after).
We named our function \lstinline{mysum} \wingding{1} and created it by using the
syntax \lstinline{<- function(...)}. 
The function consists of the lines of code between the opening \wingding{1} and
closing braces \wingding{3}.
% AF: We reference wingdings simply by describing and then putting the wingding at the end, like so. Please update throughout. 


The function takes one argument as input from the user, called \lstinline{x}. In this
case, the argument has to be a numeric vector, since we're going to perform
arithmetic operations on it.


In the \emph{body} of the function, we initialize a variable called $s$ by setting
 it to zero. 
% AF: We don't define loops until later, so I might not mention it here. "Don't worry about the details for now, but we add our variable to all the vlaues in the vector..."
Using a \lstinline{for} loop, we add to it all the values in the vector \lstinline{x}. We
\emph{return} the final value of \lstinline{s} \wingding{2}.
Note that not every function has to return a value. Some may just print something
to the screen or to a file, for example. 

Here's how we use the function:
\showChunk{R}{Code/ch1sec1-defFunc.R}{funcdefex}
%\showCode{R}{Code/ch1sec1-defFunc.R}[9][12]
\runR{Code/ch1sec1-defFunc.R}{defFunc}

% AF: Don't think we know what a distribution is yet, and it's an important idea for the chapter, so I'd give an introduction here. 
We created a sample of 10,000 number from a standard uniform distribution,
meaning that if we divide the range between 0 and 1 into
segment of equal length, then we expect to 
% in every segment of length $\ell$ between 0 and 1, we expect to
%\jy{Doesn't sound right. Let's avoid notation.}
% I removed the notation.
have the same number of random points (in this case, $10,000$ divided by the length of
a segment).
We store these 10,000 random numbers in a vector called \lstinline{simData}.
We then use it as the argument in the function \lstinline{mysum}, as well as in
\lstinline{sum}, and we print both values.
We should get the following when we run the code: 
\inlnR{cat('From sum: ', sum(simData), '. From mysum: ', mysum(simData), sep='')}[introsumsimdat].


Using arguments in function definitions is useful because you can use the
same function to perform a similar operation on different objects. For example,
the argument may be a sequence, like in the following two examples:
\showCode{R}{Code/ch1sec1-defFuncUsage.R}


Functions can take more than one argument, or they can take no arguments at all.
The arguments can also be given a default value, so that if the user does not
specify the argument, it will not cause an error. For example, we can create a
function to deal poker hands to varying number of players, and we can also
choose the number of cards each player gets:
\showCode{R}{Code/ch1sec1-PokerHand.R}
% AF: in the code, put wingdings directly in front of what they describe. In the text, put them after, like so.
We declared the default number of cards is 5 \wingding{1}, and the default number
of players is 4. So, calling the function \lstinline{drawPokerHands()} without any
arguments will give a 5-by-4 matrix of cards. Setting the second argument to 6 will
give a 5-by-6 matrix of cards.


Note that we also introduced some error-checking \wingding{2}: the function checks
if the input is valid, since it's not possible to deal more cards than we have in one deck.
If an error is detected, the function uses the built-in \lstinline{stop()} function to abort,
and shows an error message to the user.  Checking the validity of the input is very
important and helpful to the user.

\section{Generating Random Numbers}
We'll work a lot with simulated data in this book, so let's learn how to make it. The
basic function to generate random data is \lstinline{runif()}, and it's used to draw
random numbers uniformly between 0 and 1. In the following example we create
10,000 random draws from a uniform distribution, we keep these numbers in a
variable called \lstinline{simData}, and then plot a histogram to show the distribution
of the data we have generated. \index{R command!\code{runif}}
\index{Random number generation}
\index{Distribution!Uniform}
\showChunk{R}{Code/ch1sec2.R}{ch1sec2-1}


Note that the first line of code is a \emph{comment}:  anything following a \lstinline{#}
\index{Comments in R code}
character is considered a comment and is not executed by \R. We use comments to
explain to others what our code is doing.


The code should produce a \emph{histogram}, \index{Histogram} a graph in which all the observations
are put in a number of bins, and the height of each bin corresponds to the number of
observations in that bin. The histogram from the previous code segment should look
like Figure~\ref{fig:ch1:simunif1}.
\begin{figure}[H]
\includegraphics[width=0.9\textwidth]{images/chapter_1/simunif1.pdf}
\caption{A histogram of a random sample from a standard uniform distribution}\label{fig:ch1:simunif1}
\end{figure}


From the range and the flatness of the histogram in Figure~\ref{fig:ch1:simunif1},
we can see that the generated data is 
% AF: I think this is the first time we use range notation  like this, so worth saying that [] means inclusive and () means exclusive?
indeed uniform between 0 and 1, as the bins all have approximately the same height.
The \lstinline{runif()} function can be used to draw random numbers uniformly on
any finite interval. For example, if we want our random numbers to be in the
interval between 1 and 5 we can run the following code:
\showChunk{R}{Code/ch1sec2.R}{ch1sec2-2}
\noindent Try it, and draw the histogram as in the previous example. Try it with
a fixed seed and verify that you get the same output each time. Then, run the
code without a fixed seed and observe that you get different data each time.
Since the number of random draws is fairly large, the shape of the histogram
will not change much.


From a random draw of a uniform distribution we can generate random numbers from
other distributions. For example, say we want to simulate (fair) coin flips, and
count the number of heads that we get. Let's simulate 200 coin
tosses. We will draw 200 random numbers from a uniform distribution, and decide
that we got a head in the $i$-th toss if the $i$-the random number is less than
0.5, and a tail otherwise.
Try the following code multiple times (do not use \lstinline{set.seed()}). What do you
observe? We will discuss it further in a different chapter.
\showChunk{R}{Code/ch1sec2.R}{ch1sec2-3}


We have used the \lstinline{cat()} function to print (concatenate) text to the console.
Fixed text appears in double (or single) quotes, but the content of variables or
output from \R functions should not be quoted. The \lstinline{\n} symbol tells \R
to print a newline character. Try to see what happens if you remove it.


The expression within the \lstinline{sum()} function produces \lstinline{TRUE} or
\lstinline{FALSE} (\emph{Boolean})\index{Boolean} values. First, we draw \lstinline{ntrials}
random numbers from a uniform distribution. Then, each one is compared with
\lstinline{0.5}. If the value is less than 0.5, the returned value is \lstinline{TRUE}.
Otherwise, it's \lstinline{FALSE}. This demonstrates one of \R's greatest features:
it allows us to run \emph{vectorized code}\index{Vectorized code}. 
In one line, we generated 200 random
numbers and for each one we checked if it is less than 0.5, and as a result, we
got 200 Boolean values which we have added together (TRUE counts as 1,
and FALSE counts as 0.) Thus, the result in the sum is the number of heads
in 200 tosses.


The number of heads we get in this case (with this seed) is 
\inlnR{```cat(sum(runif(ntrials) < 0.5))```}[introsumruinif]. Statistical inference is based
on a mental exercise in which we ask, if we could repeat the same experiment
infinitely many times, what would we see? With simulations, we can get a good
approximation. For example, the 200 coin-tosses experiment can be repeated,
say, 100 times. One way is to use \emph{loops}, \index{Loop} like in the following example:
\showChunk{R}{Code/ch1sec2.R}{ch1sec2-4}
We've used a \lstinline{for} loop, with an index variable called \lstinline{i} that
runs from 1 to 100. In each iteration we simulated \lstinline{ntrials=200} coin
tosses, as before. The result from each iteration is stored in the $i$-th position
in the vector we called \lstinline{Heads}. 


Figure~\ref{fig:ch1:simunif2} shows the distribution of 100 simulations, where
each simulation consists of 200 coin tosses; from each of the 100 simulations,
we obtain the proportion of times we got heads.

\begin{figure}[H]
\includegraphics[width=0.9\textwidth]{images/chapter_1/simunif2.pdf}
\caption{A histogram of 100 experiments in which we flip a coin 200 time and
calculate the proportion of times we get heads out of 200}\label{fig:ch1:simunif2}
\end{figure}

Using the uniform distribution, we have created a random draw from a different
distribution, called the \emph{binomial distribution}. \index{Distribution!Binomial}
The mathematical notation
is $Bin(N, p)$ where $N$ is the number of trials such that in each trial there can
be exactly two outcomes (for example, heads or tails in coin tosses), and $p$ is
the probability of the first possible outcome (for example, head), and $1-p$ is
the probability of the second possible outcome (for example, tail).
\R has a built-in function to generate random numbers from many different
distributions, including the binomial so the code above can be replaced by
the following, which uses the \lstinline{rbinom()} function:\index{R command!\code{rbinom}}
\showChunk{R}{Code/ch1sec2.R}{ch1sec2-5}

% AF: can do exercises like this. What do you think?
%\jy{Use auto numbering.}
% We'll do that - we just have to decide how to include the exercises - in place,
% at the end of the chapter, or on github?
\begin{listhead}
\item [Exercise~1.1] Change the number of simulated coin-toss simulations
(\lstinline{nreps}) to 1,000 and rerun the code. Then change it to 10,000 and
run it again. What do you notice?
\item [Exercise~1.2] Change the probability of Heads to 0.2 and run the code
again. Then, change it to 0.8. What do you observe?
\item [Exercise~1.3] Try other values of the number of trials and the probability
of Heads.
\end{listhead}

\section{Summary Statistics}\index{Summary Statistics}

To wrap up this introduction to \R, let's introduce some statistical functions to
summarize data. 

\subsection{Generating Our Data}
First we need to generate some data:

\showChunk{R}{Code/ch1sec3.R}{ch1sec3-1}
Here, we draw 10,000 numbers from a uniform distribution, but then we calculate
the logarithm of these numbers, and divide them by \lstinline{-10}. We store these
values in the variable \lstinline{x}. 
Note that in \R the \lstinline{log} function uses the natural logarithm by default. To
use base 10 or base 2, use \lstinline{log10} and \lstinline{log2}, respectively.
To specify another base, use the \lstinline{base} argument. For example, try
\lstinline{log(16, base=4)}.

\subsection{Finding the Central Tendency}\index{Central Tendency}
The most commonly used statistical summary is the \emph{mean} (also known
\index{Mean}
as the average), $\overline{x}$:\\
$$\overline{x}=\frac{x_1+\ldots+x_n}{n}\,.$$
The mean is one way to characterize the \emph{central tendency} of a distribution.
% AF: Say what a central tendency is?
But the \emph{center} of a distribution can be defined in more than one way.
Another way is to calculate the \emph{trimmed mean}, which is similar to the mean,
\index{Trimmed mean}
except that the smallest and largest $p\cdot 100\%$  of the values are excluded
from the computation. In our example, if we take $p=0.1$ with the simulated data,
only 8,000 data points will be used in the calculation of the trimmed mean. 


A third way to estimate the central tendency is the \emph{median}, which is a
number (denoted here by $x_{0.5}$) such that half the data points are greater
than $x_{0.5}$ and half are less than or equal to $x_{0.5}$. \index{Median}


Let's compute this sample's mean, trimmed mean, and median. Notice that
in this example the mean is greater than trimmed mean, which is greater than
the median. In general, the mean is not a great estimate of the `center' of a
non-symmetric distribution. We say that the mean is more ``sensitive to extreme
values'' than the median. Here's some code to prove it:
\showChunk{R}{Code/ch1sec3.R}{ch1sec3-2}
In this example with $n=$ \inlnR{```cat(n)```}[introcatn] random numbers we
get that the mean
is \inlnR{```cat(mean(x))```}[intromeanx], the trimmed mean is
\inlnR{```cat(mean(x, trim=0.1))```}[introtrimmeanx], and the median is
\inlnR{```cat(median(x))```}[intromedianx].


\subsection{Looking at Distributions}\label{introdistributions}
The formula we used above, \lstinline{x <- - log(runif(n)) / lambda}, generates
random number from the so-called \emph{exponential distribution} with rate
\index{Distribution!Exponential}
parameter $\lambda=10$. (Don't worry about the meaning of the rate parameter.)
% AF: What does the rate parameter do? If we don't need to worry about that right now, say so.
We denote the fact that the random variable $X$ follows an exponential
distribution with rate $\lambda$  by $X\sim \exp(\lambda)$. The exponential
distribution is often used to model random waiting times, like the time between
incoming text messages. We would usually generate it by using the
\lstinline{rexp()} function in \R, like this: \lstinline{x <- rexp(n, lambda)} .
Mathematical analysis of the distribution leads to the fact that the expected value
of an exponential random variable with rate $\lambda$, is $1/\lambda$.
We see that the theoretical expected value of our example is 0.1, and the
sample mean is very close to 0.1. This is no coincidence---we'll discuss it in
a later chapter.


The distribution of \lstinline{x} is shown in Figure~\ref{fig:ch1:simexp} as a
\textit{box-and-whisker plot} (or simply, boxplot). \index{box-and-whisker plot}
\index{Boxplot}
This is a very simple representation
of numeric data, which is constructed by summarizing the data using a few
numeric characteristics. 
 
\begin{figure}[H]
\includegraphics[width=0.95\textwidth]{images/chapter_1/expdistbp.pdf}
\caption{A boxplot of data generated from an exponential distribution with
$\lambda=10$}\label{fig:ch1:simexp}
\end{figure}

In Figure~\ref{fig:ch1:simexp} the boxplot  is drawn horizontally, and the vertical grey
line inside the box is the median. Similar to the median, we find the
\emph{first quartile}, \index{Quartile} a point, $x_{0.25}$, such that 25 percent of the values are less
than $x_{0.25}$ and 75 percent are greater than $x_{25}$; we also find the
\emph{third quartile}, a point, $x_{0.75}$, such that 75 percent of the values are
less than $x_{0.75}$ and 25 percent are greater than $x_{0.75}$. The first and third
quartiles are the vertical edges of the box, also called the lower and upper
\emph{hinges}. The box represents the middle 50 percent of the data. The range
between the first and third quartiles is called the \emph{Inter-Quartile Range (IQR)},
\index{Inter-Quartile Range (IQR)}
which is sometimes used to estimate the dispersion or spread of the data.


The \emph{whiskers}, which are the dashed grey lines, are the minimum
and maximum observations within 1.5$\cdot$IQR to each side of the box. If the
result is smaller than the minimum value (or greater than the maximum), then
the whisker only extends to the minimum (or the maximum). Points within the
range between the two whiskers are not plotted individually, since their distribution
is summarized succinctly by the box-and-whiskers plot. Points outside the range
between the two whiskers are considered ``outliers,'' or extreme values, and
are shown explicitly. \index{Outliers}

The plot in Figure~\ref{fig:ch1:simexp}  was generated with the following code:

\showChunk{R}{Code/ch1sec3.R}{ch1sec3-3}

Try the code above, and try changing some of the parameters to understand their role.
We will cover the topic of visualization in Chapter~\ref{EDA}.


A boxplot does not include the mean, or the trimmed mean, but we have added them
here as a circle and diamond, respectively, in order to show that they
are different than the median. The mean is larger than the median in this case,
so we say that the distribution is \emph{skewed} to the right. \index{Distribution!skewed}
The median does not depend on observations in the tails
of the data (small and large observations in the data). It simply represents
where the data can be split in half. Thus the median is a more robust measure of
the central tendency of the data than the mean, and it is more appropriate for
skewed data such as income.


A more detailed summary of a sample can be obtained by calculating its
quantiles (also called percentiles). \index{Quantiles}
The $q$-th quantile is a number $t$, such that
$q\times 100\%$ of the data are less than or equal to $t$.
The code below will calculate the deciles (the 10, 20,.\,.\,., 90 percentiles):

\showChunk{R}{Code/ch1sec3.R}{ch1sec3-4}

In the boxplot, only three quantiles are shown. We can show the quintiles
(20, 40, 60, 80 percentiles), or deciles (10,
20,.\,.\,., 90 percentiles) by using the \lstinline{quantile()} function.
Figure~\ref{fig:ch1:simexp2} shows these quantiles as dashed vertical lines
in a histogram.

\begin{figure}[H]
\includegraphics[width=0.7\textwidth]{images/chapter_1/expdisthist.pdf}
\caption{A histogram of a sample from an exponential distribution, with the
10, 20, 30,.\,.\,. percentiles}\label{fig:ch1:simexp2}
\end{figure}

In addition to sample statistics that summarize some notion of the center of
the distribution, we are often interested in estimating the \emph{dispersion} of the
\index{Dispersion}
data, which tells us about how the data is spread out around the center of the distribution.
The most commonly used measures of dispersion are the \emph{variance}, and its\index{Variance}
square root, the \emph{standard deviation}. The sample variance is defined as:
$$Var(x)=\frac{(x_1-\overline{x})^2+\ldots+(x_n-\overline{x})^2}{n-1}$$
where $\overline{x}$ is the sample mean $\mu$.
% is the mean of the distribution of $X$.
In words, the variance is the average of the squared deviations from the mean.
Notice that the sample variance is computed with $n-1$ in the denominator
because with $n-1$ we get an \emph{unbiased estimator} for the true variance.
\index{Estimator!unbiased}


The corresponding functions in \R are \lstinline{var()} and \lstinline{sd()} for sample
\index{R command!var}\index{R command!sd}
variance and standard deviation, respectively. In the following code we also
demonstrate the \lstinline{IQR()} function, which is another common estimator for
the dispersion of a distribution. It is calculating as the difference between the third
and the first quartiles (the 75th and 25th percentiles, respectively).
\index{R command!IQR}

\showChunk{R}{Code/ch1sec3.R}{ch1sec3-5}

The most important results in statistical theory involve the \emph{normal distribution},
\index{Distribution!Normal}
so here we'll introduce it briefly.
In subsequent chapters we will elaborate on the importance of this distribution in
many applications. The normal distribution is defined by a probability density
function $\phi(x)$, with two parameters, $\mu$ and $\sigma^2$, where:
\index{Probability density function, p.d.f.}
$$\phi(x; \mu,\sigma^2)=\frac{1}{\sqrt{2\pi\sigma^2}}\exp\left[-\frac{(x-\mu)^2}{2\sigma^2}\right]\,.$$
It is symmetric, ``bell-shaped,'' and centered around the mean, $\mu$, as shown in
Figure~\ref{fig:ch1:simnorm}. 


\begin{figure}[H]
\includegraphics[width=0.7\textwidth]{images/chapter_1/normdisthist.pdf}
\caption{A histogram of a sample from a normal distribution, with mean=2.5
and variance=0.25}
\label{fig:ch1:simnorm}
\end{figure}

This histogram was generated by drawing random
numbers from a normal distribution, using the \lstinline{rnorm()} function. 
\index{R command!\code{rnorm}}
Here, we
use $\mu=2.5$ and $\sigma^2=0.25$.
The curve shows the function $\phi$, by using the \lstinline{dnorm()} function
(to obtain the density function of $x$).


Here's the code we used to create Figure~\ref{fig:ch1:simnorm}:
\showChunk{R}{Code/ch1sec3.R}{ch1sec3-6}


% AF: Want to avoid stacking, so comment on the code. Or tell them not to worry about the details.
In the next chapter we'll go into more detail about how to generate plots, but notice
how we used some arguments in the  \lstinline{hist()} and \lstinline{lines()} functions
in order to change the colors and the width of the shapes in the plot.

\subsection{Using Summary Functions}
We can obtain more detailed summaries about the sample by using the
\lstinline{summary()} function. \index{R command!\code{summary}}
It gives the minimum, maximum, the 25th, 50th,
and 75th percentiles, as well as the mean of the sample. If we use the random
numbers from the normal distribution in the previous code:
\showChunk{R}{Code/ch1sec3.R}{ch1sec3-7}
This should give us the following output:
\inlnR{```print(summary(x))```}[introsummaryx][vbox]
We can also use one of several functions from contributed packages
in order to get more detailed summaries of data. For example, the
\lstinline{stat.desc()} function from the pastecs package, or the
\lstinline{describe()} function from the psych package give additional
details such as the sample size, the minimum, the maximum, the
standard deviation, and so forth.

\subsection{Summarizing Discrete Data}
Let's conclude this chapter with some functions that can be used to
summarize discrete (categorical) data, where the mean, variance,
quantiles, and so on are not applicable. We will revisit the topic
of summarizing data in Chapter~\ref{EDA}.
\index{Categorical data}


To simulate categorical data we can use the \lstinline{rmultinom()} function,
which simulates putting $N$ objects in $K$ bins with given probabilities for
each bin. \index{R command!\code{rmultinom}}
Another possibility is to use the \lstinline{cut()} function, \index{R command!\code{cut}}
which divides a range of numbers into discrete ranges and creates categories
in a \emph{factor} variable.\index{Factor variable}
For example, suppose there is a town with three hotels (Motel 6, Best Western,
and Hilton) with 400, 300, and 300 rooms, respectively, and one auto rental
company with only two makes of cars (700 Honda, and 300 Teslas). In the
following code we simulate the allocation of 100 visitors to hotels and cars.
We use the \lstinline{table()} function to show the counts by hotel, by car,
and by both.\index{R command!\code{table}}
\showChunk{R}{Code/ch1sec3.R}{ch1sec3-8}


% AF: Update wingdings, as mentioned above.
Note that \lstinline{table()} can take one argument as in
\wingding{1} or \wingding{2}, in which case it produces the counts of
each value in its input; or it can take two arguments as in \wingding{3},
in which case it will \emph{cross-tabulate} the data, meaning that it
shows the counts for each combination of the two categorical variables.
\index{Cross tabulation}
This code produces the following output:
\inlnR{```print(table(hotelrooms));print(autotbl <- table(autorental));print(table(hotelrooms, autorental))```}[introhotel][vbox]


We can use the \lstinline{max()} and \lstinline{which.max()} functions
to find the \emph{mode} of the data (the most frequent value):\index{Mode}
\showCode{R}{Code/ch1sec3b.R}
The hotel with the largest number of guests is
\inlnR{```cat(levels(hotelrooms)[which.max(hoteltbl)])```}[introhotellevel] with
\inlnR{```cat(max(hoteltbl))```}[introhotelguests] guests, and
\inlnR{```cat(levels(autorental)[which.max(autotbl)])```}[introauto]
is rented to \inlnR{```cat(max(autotbl))```}[introautorentals] people.
\index{R command!\code{max}}
\index{R command!\code{which.max}}

\section{Summary}
% AF: End chapters with a summary section that briefly summarizes what we've covered, and previews the next chapter.
In this chapter we described how to install \R and introduced some
basic functions. We learned how to use variables, create and run
our own functions, and covered some basic notions in descriptive
statistics. In the next chapter we will elaborate on \emph{exploratory
data analysis (EDA)} and see how to create tables and plots.

%%% Local Variables:
%%% mode: latex
%%% TeX-command-extra-options: "-shell-escape"
%%% TeX-engine: xetex
%%% TeX-master: "../sidsmain.tex"
%%% End:
